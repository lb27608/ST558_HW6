[
  {
    "objectID": "ST558_HW6.html",
    "href": "ST558_HW6.html",
    "title": "ST 558 Homework 6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\n\nThe purpose of lapply() is to call a specified function for each element of a list. In purrr, the equivalent function is map().\n\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = \"kendall\" when calling lapply())\n\n\nThe code that would perform this action is lapply(X=my_list, FUN=cor, method=\"kendall\")\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\n\n\nFunctions in purrr provide consistent syntax (e.g., the first argument to map functions is always the data, which is not the case for the apply family).\npurrr provides useful helper functions that are not available for the base R apply family.\n\n\n\nWhat is a side-effect function?\n\n\nA function that produces some sort of effect in addition to the value that it is designed to return, such as creating a plot or modifying an object in the environment besides the object that it returns.\n\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\n\nBecause of name masking of objects that takes place as a result of lexical scoping, if you include a variable named sd within a custom function, R will mask the sd function within the custom function. When sd is referenced inside the custom function, R will refer to the variable. Outside the custom function, sd will still represent the built-in function for standard deviation."
  },
  {
    "objectID": "ST558_HW6.html#conceptual-questions",
    "href": "ST558_HW6.html#conceptual-questions",
    "title": "ST 558 Homework 6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\n\nThe purpose of lapply() is to call a specified function for each element of a list. In purrr, the equivalent function is map().\n\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = \"kendall\" when calling lapply())\n\n\nThe code that would perform this action is lapply(X=my_list, FUN=cor, method=\"kendall\")\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\n\n\nFunctions in purrr provide consistent syntax (e.g., the first argument to map functions is always the data, which is not the case for the apply family).\npurrr provides useful helper functions that are not available for the base R apply family.\n\n\n\nWhat is a side-effect function?\n\n\nA function that produces some sort of effect in addition to the value that it is designed to return, such as creating a plot or modifying an object in the environment besides the object that it returns.\n\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\n\nBecause of name masking of objects that takes place as a result of lexical scoping, if you include a variable named sd within a custom function, R will mask the sd function within the custom function. When sd is referenced inside the custom function, R will refer to the variable. Outside the custom function, sd will still represent the built-in function for standard deviation."
  },
  {
    "objectID": "ST558_HW6.html#writing-r-functions",
    "href": "ST558_HW6.html#writing-r-functions",
    "title": "ST 558 Homework 6",
    "section": "Writing R Functions",
    "text": "Writing R Functions\n\nRMSE function\nFirst, we’ll create a function to compute the root mean square error (RMSE) as a metric for the difference between a vector of observed data (resp) and a vector of predictions (pred). To allow for missing data, the function includes an unnamed argument (...) so that the rm.na option can be used with the mean function to remove those missing values:\n\ngetRMSE &lt;- function(resp, pred, ...) {\n  if(length(resp) != length(pred)) {\n    stop(\"Response and prediction vectors must be the same length.\")\n  }\n  \n  rmse &lt;- sqrt(mean((resp-pred)^2,...,))\n  return(rmse)\n}\n\nNow we’ll create some test data to evaluate the performance of the function, first with a set of values with no missing data:\n\n# Generate test data\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp~ x), data.frame(x))\n\n# Test function with complete data\ngetRMSE(resp,pred)\n\n[1] 0.9581677\n\n\nAnd now with two of the responses replaced by missing values:\n\n# Replace two response values with missing values\nresp[3] &lt;- NA_real_\nresp[45] &lt;- NA_real_\n\n# Test function with and without na.rm=TRUE to remove missings\n\ngetRMSE(resp,pred)\n\n[1] NA\n\ngetRMSE(resp,pred, na.rm=TRUE)\n\n[1] 0.9563828\n\n\nWe see that without na.rm=TRUE, the function will return NA in the presence of a missing response value. When the option to remove missing values is specified, the function returns a valid numeric result.\n\n\nMAE function\nNow we’ll create a similar function to compute the mean absolute error (MAE) based on a response vector and a prediction vector:\n\ngetMAE &lt;- function(resp, pred, ...) {\n  if(length(resp) != length(pred)) {\n    stop(\"Response and prediction vectors must be the same length.\")\n  }\n  \n  mae &lt;- mean(abs(resp-pred),...,)\n  return(mae)\n}\n\nAs before, we’ll create some simulated data to test the MAE function:\n\n# Generate test data\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp~ x), data.frame(x))\n\n# Test function with complete data\ngetMAE(resp,pred)\n\n[1] 0.8155776\n\n\nSo far, so good. Let’s make sure it works when missing data is present in the response vector:\n\n# Replace two response values with missing values\nresp[3] &lt;- NA_real_\nresp[45] &lt;- NA_real_\n\n# Test function with and without na.rm=TRUE to remove missings\n\ngetMAE(resp,pred)\n\n[1] NA\n\ngetMAE(resp,pred, na.rm=TRUE)\n\n[1] 0.8121784\n\n\nWe see the same sort of result here that we saw with getRMSE.\n\n\nWrapper function\nThe final step for this task is to create a wrapper function that calls the getRMSE and getMAE helper functions. This wrapper (getDev) allows a user to specify the error metrics to be returned via the metrics= option.\n\n#Create wrapper function getDev to compute RMSE and/or MAE\n\ngetDev &lt;- function(resp,pred,metrics=\"RMSE,MAE\",...){\n  if (!(is.vector(resp) & is.numeric(resp) | !(is.vector(pred) & is.numeric(pred)))) {\n    stop(\"Both response and predicted must be numeric vectors.\")\n  }\n  \n  if(str_detect(metrics,\"RMSE\")) {\n    rmse_result &lt;- getRMSE(resp=resp,pred=pred,...)\n  } else rmse_result=NA;\n  \n  if(str_detect(metrics,\"MAE\")) {\n    mae_result &lt;- getMAE(resp=resp,pred=pred,...)\n  } else mae_result=NA;\n  \n  final&lt;-list(RMSE=rmse_result,MAE=mae_result)\n  return(final)\n}\n\nThe first test of this wrapper function will use another simulated dataset to verify that it works for complete data:\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp~ x), data.frame(x))\n\n#Return both RMSE and MAE by default\ngetDev(resp,pred)\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.8155776\n\n\nNext, we’ll check the function to make sure it returns specified metrics individually:\n\ngetDev(resp,pred,metrics=\"RMSE\")\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] NA\n\n\n\ngetDev(resp,pred,metrics=\"MAE\")\n\n$RMSE\n[1] NA\n\n$MAE\n[1] 0.8155776\n\n\nDoes it work when missing data is present? Let’s find out.\n\n# Replace two response values with missing values\nresp[3] &lt;- NA_real_\nresp[45] &lt;- NA_real_\n\n# Test function with and without na.rm=TRUE to remove missings\n\ngetDev(resp,pred)\n\n$RMSE\n[1] NA\n\n$MAE\n[1] NA\n\ngetDev(resp,pred,na.rm=TRUE)\n\n$RMSE\n[1] 0.9563828\n\n$MAE\n[1] 0.8121784\n\n\nWe see again that without specifying na.rm=TRUE, the wrapper function returns NA for both metrics. When we add the argument to remove the missing values, the function returns valid metric values.\nAs a final check of the function, we’ll try passing the data frame cars instead of a vector for the response:\n\ngetDev(cars,pred)\n\nError in getDev(cars, pred): Both response and predicted must be numeric vectors."
  },
  {
    "objectID": "ST558_HW6.html#querying-an-api-and-a-tidy-style-function",
    "href": "ST558_HW6.html#querying-an-api-and-a-tidy-style-function",
    "title": "ST 558 Homework 6",
    "section": "Querying an API and a Tidy-Style Function",
    "text": "Querying an API and a Tidy-Style Function\nFor this task, we’ll first test a query from NewsAPI by retrieving data for stories about Apple between 1 October and 15 October:\n\nnews_test &lt;- \"https://newsapi.org/v2/everything?q=apple&from=2024-10-01&to=2024-10-15&sortBy=popularity&apiKey=faf3bacb727e4d8185a26d37e070b361\"\n\nnews_test_tbl &lt;- httr::GET(news_test) \nparsed&lt;-fromJSON(rawToChar(news_test_tbl$content),flatten = TRUE, simplifyDataFrame = TRUE)\narticles &lt;- parsed |&gt; pluck(\"articles\")\n\nNext, we create a custom function that allows a user to specify a topic, a date to start the search, and an API key. The function will return the articles data frame from the query:\n\ngetNews &lt;- function(topic,from=today(),apikey=\"faf3bacb727e4d8185a26d37e070b361\") {\n  \n  start_url &lt;-\"https://newsapi.org/v2/everything?q=\"\n  end_url &lt;-\"&sortBy=popularity&apiKey=\"\n  from_dt &lt;-ymd(from)\n  to_dt &lt;- ymd(today())\n  topic_url &lt;- noquote(topic)\n  complete_url&lt;-paste0(start_url,topic_url,\"&from=\",from_dt,\"&to=\",to_dt,end_url,apikey)\n\n  raw_data &lt;- httr::GET(complete_url)\n  parsed_data &lt;- fromJSON(rawToChar(raw_data$content),flatten = TRUE, simplifyDataFrame = TRUE)\n  articles &lt;- parsed |&gt; pluck(\"articles\")\n  return(articles)\n}\n\nLet’s get information about stories involving Toyota and stories about Tesla:\n\ntoyota_data &lt;- getNews(topic=\"toyota\")\ntesla_data &lt;- getNews(topic=\"tesla\")\n\nWe can see the sources of the stories by summarizing on the source.name variable in the Toyota data:\n\ntable(toyota_data$source.name)\n\n\n          [Removed]         Gizmodo.com           The Verge               Wired \n                 20                  38                  17                   5 \nYahoo Entertainment \n                 20 \n\n\nNext, we’ll turn the information in the variable publishedAt into a new column containing only the date of publication for each data frame. We will then sort on the publication date and compute the difference in days between each publication and the one before it:\n\ntoyota_data_2 &lt;- toyota_data |&gt; mutate(publishedDate = date(ymd_hms(publishedAt))) |&gt;arrange(publishedDate) |&gt; mutate(pub_diff=publishedDate-lag(publishedDate))\n\ntesla_data_2 &lt;- tesla_data |&gt; mutate(publishedDate = date(ymd_hms(publishedAt))) |&gt;arrange(publishedDate) |&gt; mutate(pub_diff=publishedDate-lag(publishedDate))\n\nLastly, we’ll keep on the publication date and difference columns of each data frame and summarize them:\n\ntoyota_final &lt;- toyota_data_2 |&gt; select(publishedDate, pub_diff)\ntesla_final &lt;- tesla_data_2 |&gt; select(publishedDate, pub_diff)\n\ntoyota_summary&lt;-map(toyota_final,\\(x) list(mean=mean(x,na.rm=TRUE),sd=sd(x,na.rm=TRUE),median=median(x,na.rm=TRUE)))\n\ntesla_summary&lt;-map(tesla_final,\\(x) list(mean=mean(x,na.rm=TRUE),sd=sd(x,na.rm=TRUE),median=median(x,na.rm=TRUE)))\n\nlist(toyota=toyota_summary,tesla=tesla_summary)\n\n$toyota\n$toyota$publishedDate\n$toyota$publishedDate$mean\n[1] \"2024-10-07\"\n\n$toyota$publishedDate$sd\n[1] 4.071879\n\n$toyota$publishedDate$median\n[1] \"2024-10-08\"\n\n\n$toyota$pub_diff\n$toyota$pub_diff$mean\nTime difference of 0.1414141 days\n\n$toyota$pub_diff$sd\n[1] 0.3782371\n\n$toyota$pub_diff$median\nTime difference of 0 days\n\n\n\n$tesla\n$tesla$publishedDate\n$tesla$publishedDate$mean\n[1] \"2024-10-07\"\n\n$tesla$publishedDate$sd\n[1] 4.071879\n\n$tesla$publishedDate$median\n[1] \"2024-10-08\"\n\n\n$tesla$pub_diff\n$tesla$pub_diff$mean\nTime difference of 0.1414141 days\n\n$tesla$pub_diff$sd\n[1] 0.3782371\n\n$tesla$pub_diff$median\nTime difference of 0 days"
  }
]